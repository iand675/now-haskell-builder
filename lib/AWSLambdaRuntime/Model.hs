{-
   AWS Lambda Runtime API

   AWS Lambda Runtime API is an HTTP API for implementing custom runtimes

   OpenAPI Version: 3.0.0
   AWS Lambda Runtime API API version: 1.0.3
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : AWSLambdaRuntime.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module AWSLambdaRuntime.Model where

import AWSLambdaRuntime.Core
import AWSLambdaRuntime.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** AwsRequestId
newtype AwsRequestId = AwsRequestId { unAwsRequestId :: Text } deriving (P.Eq, P.Show)

-- ** Body
newtype Body = Body { unBody :: A.Value } deriving (P.Eq, P.Show, A.ToJSON)

-- ** LambdaRuntimeFunctionErrorType
newtype LambdaRuntimeFunctionErrorType = LambdaRuntimeFunctionErrorType { unLambdaRuntimeFunctionErrorType :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ErrorRequest
-- | ErrorRequest
data ErrorRequest = ErrorRequest
  { errorRequestErrorMessage :: !(Maybe Text) -- ^ "errorMessage"
  , errorRequestErrorType :: !(Maybe Text) -- ^ "errorType"
  , errorRequestStackTrace :: !(Maybe [Text]) -- ^ "stackTrace"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorRequest
instance A.FromJSON ErrorRequest where
  parseJSON = A.withObject "ErrorRequest" $ \o ->
    ErrorRequest
      <$> (o .:? "errorMessage")
      <*> (o .:? "errorType")
      <*> (o .:? "stackTrace")

-- | ToJSON ErrorRequest
instance A.ToJSON ErrorRequest where
  toJSON ErrorRequest {..} =
   _omitNulls
      [ "errorMessage" .= errorRequestErrorMessage
      , "errorType" .= errorRequestErrorType
      , "stackTrace" .= errorRequestStackTrace
      ]


-- | Construct a value of type 'ErrorRequest' (by applying it's required fields, if any)
mkErrorRequest
  :: ErrorRequest
mkErrorRequest =
  ErrorRequest
  { errorRequestErrorMessage = Nothing
  , errorRequestErrorType = Nothing
  , errorRequestStackTrace = Nothing
  }

-- ** ErrorResponse
-- | ErrorResponse
data ErrorResponse = ErrorResponse
  { errorResponseErrorMessage :: !(Maybe Text) -- ^ "errorMessage"
  , errorResponseErrorType :: !(Maybe Text) -- ^ "errorType"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:? "errorMessage")
      <*> (o .:? "errorType")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "errorMessage" .= errorResponseErrorMessage
      , "errorType" .= errorResponseErrorType
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: ErrorResponse
mkErrorResponse =
  ErrorResponse
  { errorResponseErrorMessage = Nothing
  , errorResponseErrorType = Nothing
  }

-- ** StatusResponse
-- | StatusResponse
data StatusResponse = StatusResponse
  { statusResponseStatus :: !(Maybe Text) -- ^ "status"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StatusResponse
instance A.FromJSON StatusResponse where
  parseJSON = A.withObject "StatusResponse" $ \o ->
    StatusResponse
      <$> (o .:? "status")

-- | ToJSON StatusResponse
instance A.ToJSON StatusResponse where
  toJSON StatusResponse {..} =
   _omitNulls
      [ "status" .= statusResponseStatus
      ]


-- | Construct a value of type 'StatusResponse' (by applying it's required fields, if any)
mkStatusResponse
  :: StatusResponse
mkStatusResponse =
  StatusResponse
  { statusResponseStatus = Nothing
  }





